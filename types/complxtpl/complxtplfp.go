// Code generated by 'gofp'. DO NOT EDIT.
package complxtpl

import "reflect"
import _ "sort"
import "sync"
import "github.com/logic-building/functional-go/fp"

func MapComplexTupla(f func(ComplexTupla) ComplexTupla, list []ComplexTupla) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}
	newList := make([]ComplexTupla, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapComplexTuplaPtr(f func(*ComplexTupla) *ComplexTupla, list []*ComplexTupla) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}
	newList := make([]*ComplexTupla, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapComplexTuplaPtrErr takes 2 arguments:
//  1. A function input argument: *ComplexTupla and return types (*ComplexTupla, error)
//  2. A list of type []*ComplexTupla
//
// Returns:
// 	([]*ComplexTupla, error)
func MapComplexTuplaPtrErr(f func(*ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}
	newList := make([]*ComplexTupla, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapComplexTuplaErr takes 2 arguments:
//  1. A function input argument: ComplexTupla and return types (ComplexTupla, error)
//  2. A list of type []ComplexTupla
//
// Returns:
// 	([]ComplexTupla, error)
func MapComplexTuplaErr(f func(ComplexTupla) (ComplexTupla, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}
	newList := make([]ComplexTupla, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}
	var newList []ComplexTupla
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}
	var newList []*ComplexTupla
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterComplexTuplaPtrErr takes two arguments
//  1. Function: takes 1 argument of type ComplexTupla and returns (bool, error)
//  2. slice of type []*ComplexTupla
//
// Returns:
//  new filtered list and error
func FilterComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}
	var newList []*ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterComplexTuplaErr takes two arguments
//  1. Function: takes 1 argument of type ComplexTupla and returns (bool, error)
//  2. slice of type []ComplexTupla
//
// Returns:
//  new filtered list and error
func FilterComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}
	var newList []ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}
	var newList []ComplexTupla
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}
	var newList []*ComplexTupla
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveComplexTuplaPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *ComplexTupla and return types(bool, error)
//	2. List of type: []*ComplexTupla
//
// Returns:
//	New list and error: ([]*ComplexTupla, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}
	var newList []*ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveComplexTuplaErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type ComplexTupla and return types(bool, error)
//	2. List of type: []ComplexTupla
//
// Returns:
//	New list and error: ([]ComplexTupla, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}
	var newList []ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeComplexTuplaPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeComplexTuplaErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryComplexTuplaPtrErr returns true if supplied function returns logical true for every item in the list
func EveryComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryComplexTuplaErr returns true if supplied function returns logical true for every item in the list
func EveryComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}
	var newList []ComplexTupla
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]ComplexTupla, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}
	var newList []*ComplexTupla
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*ComplexTupla, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileComplexTuplaPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}
	var newList []*ComplexTupla
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*ComplexTupla, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileComplexTuplaErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}
	var newList []ComplexTupla
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]ComplexTupla, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileComplexTupla(f func(ComplexTupla) bool, list []ComplexTupla) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}
	var newList []ComplexTupla
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileComplexTuplaPtr(f func(*ComplexTupla) bool, list []*ComplexTupla) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}
	var newList []*ComplexTupla
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileComplexTuplaPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *ComplexTupla and returns ([]*ComplexTupla, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileComplexTuplaPtrErr(f func(*ComplexTupla) (bool, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}
	var newList []*ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileComplexTuplaErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type ComplexTupla and returns ([]ComplexTupla, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileComplexTuplaErr(f func(ComplexTupla) (bool, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}
	var newList []ComplexTupla
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapComplexTupla applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapComplexTupla(f func(ComplexTupla) ComplexTupla, list []ComplexTupla, optional ...fp.Optional) []ComplexTupla {
	if f == nil {
		return []ComplexTupla{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapComplexTuplaNoOrder(f, list, worker)
		}
	}

	return pMapComplexTuplaPreserveOrder(f, list, worker)
}

func pMapComplexTuplaPreserveOrder(f func(ComplexTupla) ComplexTupla, list []ComplexTupla, worker int) []ComplexTupla {
	chJobs := make(chan map[int]ComplexTupla, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]ComplexTupla{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]ComplexTupla, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]ComplexTupla, chJobs chan map[int]ComplexTupla) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]ComplexTupla{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]ComplexTupla, len(list))
	newList := make([]ComplexTupla, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapComplexTuplaNoOrder(f func(ComplexTupla) ComplexTupla, list []ComplexTupla, worker int) []ComplexTupla {
	chJobs := make(chan ComplexTupla, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan ComplexTupla, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan ComplexTupla, chJobs chan ComplexTupla) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]ComplexTupla, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapComplexTuplaPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapComplexTuplaPtr(f func(*ComplexTupla) *ComplexTupla, list []*ComplexTupla, optional ...fp.Optional) []*ComplexTupla {
	if f == nil {
		return []*ComplexTupla{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapComplexTuplaPtrNoOrder(f, list, worker)
		}
	}

	return pMapComplexTuplaPtrPreserveOrder(f, list, worker)
}

func pMapComplexTuplaPtrPreserveOrder(f func(*ComplexTupla) *ComplexTupla, list []*ComplexTupla, worker int) []*ComplexTupla {
	chJobs := make(chan map[int]*ComplexTupla, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*ComplexTupla{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*ComplexTupla, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*ComplexTupla, chJobs chan map[int]*ComplexTupla) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*ComplexTupla{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*ComplexTupla, len(list))
	newList := make([]*ComplexTupla, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapComplexTuplaPtrNoOrder(f func(*ComplexTupla) *ComplexTupla, list []*ComplexTupla, worker int) []*ComplexTupla {
	chJobs := make(chan *ComplexTupla, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *ComplexTupla, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *ComplexTupla, chJobs chan *ComplexTupla) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*ComplexTupla, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapComplexTuplaPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapComplexTuplaPtrErr(f func(*ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla, optional ...fp.Optional) ([]*ComplexTupla, error) {
	if f == nil {
		return []*ComplexTupla{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapComplexTuplaPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapComplexTuplaPtrErrPreserveOrder(f, list, worker)
}

func pMapComplexTuplaPtrErrPreserveOrder(f func(*ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla, worker int) ([]*ComplexTupla, error) {
	chJobs := make(chan map[int]*ComplexTupla, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*ComplexTupla{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*ComplexTupla, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*ComplexTupla, chJobs chan map[int]*ComplexTupla, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*ComplexTupla{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*ComplexTupla, len(list))
	newList := make([]*ComplexTupla, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*ComplexTupla{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*ComplexTupla{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapComplexTuplaPtrErrNoOrder(f func(*ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla, worker int) ([]*ComplexTupla, error) {
	chJobs := make(chan *ComplexTupla, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *ComplexTupla, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *ComplexTupla, chJobs chan *ComplexTupla, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*ComplexTupla, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*ComplexTupla{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*ComplexTupla{}, <-errCh
	}

	return newList, nil
}

// PMapComplexTuplaErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapComplexTuplaErr(f func(ComplexTupla) (ComplexTupla, error), list []ComplexTupla, optional ...fp.Optional) ([]ComplexTupla, error) {
	if f == nil {
		return []ComplexTupla{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapComplexTuplaErrNoOrder(f, list, worker)
		}
	}

	return pMapComplexTuplaErrPreserveOrder(f, list, worker)
}

func pMapComplexTuplaErrPreserveOrder(f func(ComplexTupla) (ComplexTupla, error), list []ComplexTupla, worker int) ([]ComplexTupla, error) {
	chJobs := make(chan map[int]ComplexTupla, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]ComplexTupla{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]ComplexTupla, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]ComplexTupla, chJobs chan map[int]ComplexTupla, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]ComplexTupla{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]ComplexTupla, len(list))
	newList := make([]ComplexTupla, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []ComplexTupla{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []ComplexTupla{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapComplexTuplaErrNoOrder(f func(ComplexTupla) (ComplexTupla, error), list []ComplexTupla, worker int) ([]ComplexTupla, error) {
	chJobs := make(chan ComplexTupla, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan ComplexTupla, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan ComplexTupla, chJobs chan ComplexTupla, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]ComplexTupla, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []ComplexTupla{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []ComplexTupla{}, <-errCh
	}

	return newList, nil
}

func FilterMapComplexTupla(fFilter func(ComplexTupla) bool, fMap func(ComplexTupla) ComplexTupla, list []ComplexTupla) []ComplexTupla {
	if fFilter == nil || fMap == nil {
		return []ComplexTupla{}
	}
	var newList []ComplexTupla
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapComplexTuplaPtr(fFilter func(*ComplexTupla) bool, fMap func(*ComplexTupla) *ComplexTupla, list []*ComplexTupla) []*ComplexTupla {
	if fFilter == nil || fMap == nil {
		return []*ComplexTupla{}
	}
	var newList []*ComplexTupla
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapComplexTuplaPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*ComplexTupla) and returns (bool, error).
//	2. Function: takes *ComplexTupla as argument and returns (*ComplexTupla, error)
// 	3. Slice of type []*ComplexTupla
//
// Returns:
//	New List ([]*ComplexTupla, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapComplexTuplaPtrErr(fFilter func(*ComplexTupla) (bool, error), fMap func(*ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla) ([]*ComplexTupla, error) {
	if fFilter == nil || fMap == nil {
		return []*ComplexTupla{}, nil
	}
	var newList []*ComplexTupla
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapComplexTuplaErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(ComplexTupla) and returns (bool, error).
//	2. Function: takes ComplexTupla as argument and returns (ComplexTupla, error)
// 	3. Slice of type []ComplexTupla
//
// Returns:
//	New List ([]ComplexTupla, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapComplexTuplaErr(fFilter func(ComplexTupla) (bool, error), fMap func(ComplexTupla) (ComplexTupla, error), list []ComplexTupla) ([]ComplexTupla, error) {
	if fFilter == nil || fMap == nil {
		return []ComplexTupla{}, nil
	}
	var newList []ComplexTupla
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestComplexTupla(l []ComplexTupla) []ComplexTupla {
	if l == nil {
		return []ComplexTupla{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []ComplexTupla{}
	}

	newList := make([]ComplexTupla, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

// RestComplexTupla removes 1st item of the list and return new list having rest of the items
func RestComplexTuplaPtr(l []*ComplexTupla) []*ComplexTupla {
	if l == nil {
		return []*ComplexTupla{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*ComplexTupla{}
	}

	newList := make([]*ComplexTupla, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceComplexTupla(f func(ComplexTupla, ComplexTupla) ComplexTupla, list []ComplexTupla, initializer ...ComplexTupla) ComplexTupla {
	var init ComplexTupla
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceComplexTupla(f, list[1:], r)
}

func ReduceComplexTuplaPtr(f func(*ComplexTupla, *ComplexTupla) *ComplexTupla, list []*ComplexTupla, initializer ...ComplexTupla) *ComplexTupla {
	var initVal ComplexTupla
	var init *ComplexTupla = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceComplexTuplaPtr(f, list[1:], *r)
}

// ReduceComplexTuplaPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*ComplexTupla, *ComplexTupla)
//	B. list of type []*ComplexTupla
// 	C. initializer (optional of type ComplexTupla)
//
// Returns:
//	single value, error: (*ComplexTupla, error)
func ReduceComplexTuplaPtrErr(f func(*ComplexTupla, *ComplexTupla) (*ComplexTupla, error), list []*ComplexTupla, initializer ...ComplexTupla) (*ComplexTupla, error) {
	var initVal ComplexTupla
	var init *ComplexTupla = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceComplexTuplaPtrErr(f, list[1:], *r)
}

// ReduceComplexTuplaErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (ComplexTupla, ComplexTupla)
//	B. list of type []ComplexTupla
// 	C. initializer (optional of type ComplexTupla)
//
// Returns:
//	single value, error: (ComplexTupla, error)
func ReduceComplexTuplaErr(f func(ComplexTupla, ComplexTupla) (ComplexTupla, error), list []ComplexTupla, initializer ...ComplexTupla) (ComplexTupla, error) {
	var initVal ComplexTupla
	var init ComplexTupla = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceComplexTuplaErr(f, list[1:], r)
}

// DropLastComplexTupla drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastComplexTupla(list []ComplexTupla) []ComplexTupla {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []ComplexTupla{}
	}

	newList := make([]ComplexTupla, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastComplexTuplaPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastComplexTuplaPtr(list []*ComplexTupla) []*ComplexTupla {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*ComplexTupla{}
	}

	newList := make([]*ComplexTupla, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseComplexTuplas reverse the list
func ReverseComplexTuplas(list []ComplexTupla) []ComplexTupla {
	newList := make([]ComplexTupla, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseComplexTuplasPtr reverse the list
func ReverseComplexTuplasPtr(list []*ComplexTupla) []*ComplexTupla {
	newList := make([]*ComplexTupla, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeComplexTupla returns n items in the list
func TakeComplexTupla(n int, list []ComplexTupla) []ComplexTupla {
	if n < 0 {
		return []ComplexTupla{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]ComplexTupla, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeComplexTuplaPtr returns n items in the list
func TakeComplexTuplaPtr(n int, list []*ComplexTupla) []*ComplexTupla {
	if n < 0 {
		return []*ComplexTupla{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*ComplexTupla, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctComplexTuplaP returns true if no two of the arguments are =
func DistinctComplexTuplaP(list []ComplexTupla) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctComplexTuplaPPtr returns true if no two of the arguments are =
func DistinctComplexTuplaPPtr(list []*ComplexTupla) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctComplexTupla removes duplicates.
func DistinctComplexTupla(list []ComplexTupla) []ComplexTupla {
	if len(list) == 0 {
		return []ComplexTupla{}
	}

	newList := []ComplexTupla{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctComplexTuplaPtr(list []*ComplexTupla) []*ComplexTupla {
	if len(list) == 0 {
		return []*ComplexTupla{}
	}

	newList := []*ComplexTupla{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// UnionComplexTupla return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionComplexTupla(arrList ...[]ComplexTupla) []ComplexTupla {
	var newList []ComplexTupla

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionComplexTuplaPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionComplexTuplaPtr(arrList ...[]*ComplexTupla) []*ComplexTupla {
	var newList []*ComplexTupla

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// IntersectionComplexTupla return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionComplexTupla(arrList ...[]ComplexTupla) []ComplexTupla {
	if arrList == nil {
		return []ComplexTupla{}
	}

	var newList []ComplexTupla

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionComplexTuplaPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionComplexTuplaPtr(arrList ...[]*ComplexTupla) []*ComplexTupla {
	if arrList == nil {
		return []*ComplexTupla{}
	}

	var newList []*ComplexTupla

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceComplexTupla returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceComplexTupla(arrList ...[]ComplexTupla) []ComplexTupla {
	if arrList == nil {
		return []ComplexTupla{}
	}

	var newList []ComplexTupla

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceComplexTuplaPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceComplexTuplaPtr(arrList ...[]*ComplexTupla) []*ComplexTupla {
	if arrList == nil {
		return []*ComplexTupla{}
	}

	var newList []*ComplexTupla

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// SubsetComplexTupla returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetComplexTupla(list1, list2 []ComplexTupla) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetComplexTuplaPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetComplexTuplaPtr(list1, list2 []*ComplexTupla) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetComplexTupla returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetComplexTupla(list1, list2 []ComplexTupla) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetComplexTuplaPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetComplexTuplaPtr(list1, list2 []*ComplexTupla) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SetComplexTupla returns a set of the distinct elements of coll.
func SetComplexTupla(list []ComplexTupla) []ComplexTupla {
	if len(list) == 0 {
		return []ComplexTupla{}
	}

	newList := []ComplexTupla{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetComplexTuplaPtr returns a set of the distinct elements of coll.
func SetComplexTuplaPtr(list []*ComplexTupla) []*ComplexTupla {
	if len(list) == 0 {
		return []*ComplexTupla{}
	}

	newList := []*ComplexTupla{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}
