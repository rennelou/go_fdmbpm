// Code generated by 'gofp'. DO NOT EDIT.
package complxtpl

import _ "reflect"
import _ "sort"
import "sync"
import "github.com/logic-building/functional-go/fp"

func Mapcomplex128(f func(complex128) complex128, list []complex128) []complex128 {
	if f == nil {
		return []complex128{}
	}
	newList := make([]complex128, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func Mapcomplex128Ptr(f func(*complex128) *complex128, list []*complex128) []*complex128 {
	if f == nil {
		return []*complex128{}
	}
	newList := make([]*complex128, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// Mapcomplex128PtrErr takes 2 arguments:
//  1. A function input argument: *complex128 and return types (*complex128, error)
//  2. A list of type []*complex128
//
// Returns:
// 	([]*complex128, error)
func Mapcomplex128PtrErr(f func(*complex128) (*complex128, error), list []*complex128) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}
	newList := make([]*complex128, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// Mapcomplex128Err takes 2 arguments:
//  1. A function input argument: complex128 and return types (complex128, error)
//  2. A list of type []complex128
//
// Returns:
// 	([]complex128, error)
func Mapcomplex128Err(f func(complex128) (complex128, error), list []complex128) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}
	newList := make([]complex128, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func Filtercomplex128(f func(complex128) bool, list []complex128) []complex128 {
	if f == nil {
		return []complex128{}
	}
	var newList []complex128
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func Filtercomplex128Ptr(f func(*complex128) bool, list []*complex128) []*complex128 {
	if f == nil {
		return []*complex128{}
	}
	var newList []*complex128
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// Filtercomplex128PtrErr takes two arguments
//  1. Function: takes 1 argument of type complex128 and returns (bool, error)
//  2. slice of type []*complex128
//
// Returns:
//  new filtered list and error
func Filtercomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}
	var newList []*complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// Filtercomplex128Err takes two arguments
//  1. Function: takes 1 argument of type complex128 and returns (bool, error)
//  2. slice of type []complex128
//
// Returns:
//  new filtered list and error
func Filtercomplex128Err(f func(complex128) (bool, error), list []complex128) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}
	var newList []complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Removecomplex128(f func(complex128) bool, list []complex128) []complex128 {
	if f == nil {
		return []complex128{}
	}
	var newList []complex128
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func Removecomplex128Ptr(f func(*complex128) bool, list []*complex128) []*complex128 {
	if f == nil {
		return []*complex128{}
	}
	var newList []*complex128
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// Removecomplex128PtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *complex128 and return types(bool, error)
//	2. List of type: []*complex128
//
// Returns:
//	New list and error: ([]*complex128, error)
//	Empty list if both of arguments are nil or either one is nil.
func Removecomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}
	var newList []*complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// Removecomplex128Err removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type complex128 and return types(bool, error)
//	2. List of type: []complex128
//
// Returns:
//	New list and error: ([]complex128, error)
//	Empty list if both of arguments are nil or either one is nil.
func Removecomplex128Err(f func(complex128) (bool, error), list []complex128) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}
	var newList []complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func Somecomplex128(f func(complex128) bool, list []complex128) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func Somecomplex128Ptr(f func(*complex128) bool, list []*complex128) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// Somecomplex128PtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func Somecomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// Somecomplex128Err finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func Somecomplex128Err(f func(complex128) (bool, error), list []complex128) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func Everycomplex128(f func(complex128) bool, list []complex128) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func Everycomplex128Ptr(f func(*complex128) bool, list []*complex128) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// Everycomplex128PtrErr returns true if supplied function returns logical true for every item in the list
func Everycomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// Everycomplex128Err returns true if supplied function returns logical true for every item in the list
func Everycomplex128Err(f func(complex128) (bool, error), list []complex128) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhilecomplex128(f func(complex128) bool, list []complex128) []complex128 {
	if f == nil {
		return []complex128{}
	}
	var newList []complex128
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]complex128, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhilecomplex128Ptr(f func(*complex128) bool, list []*complex128) []*complex128 {
	if f == nil {
		return []*complex128{}
	}
	var newList []*complex128
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*complex128, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhilecomplex128PtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhilecomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}
	var newList []*complex128
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*complex128, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhilecomplex128Err drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhilecomplex128Err(f func(complex128) (bool, error), list []complex128) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}
	var newList []complex128
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]complex128, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhilecomplex128(f func(complex128) bool, list []complex128) []complex128 {
	if f == nil {
		return []complex128{}
	}
	var newList []complex128
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhilecomplex128Ptr(f func(*complex128) bool, list []*complex128) []*complex128 {
	if f == nil {
		return []*complex128{}
	}
	var newList []*complex128
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhilecomplex128PtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *complex128 and returns ([]*complex128, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhilecomplex128PtrErr(f func(*complex128) (bool, error), list []*complex128) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}
	var newList []*complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhilecomplex128Err returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type complex128 and returns ([]complex128, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhilecomplex128Err(f func(complex128) (bool, error), list []complex128) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}
	var newList []complex128
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapcomplex128 applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapcomplex128(f func(complex128) complex128, list []complex128, optional ...fp.Optional) []complex128 {
	if f == nil {
		return []complex128{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapcomplex128NoOrder(f, list, worker)
		}
	}

	return pMapcomplex128PreserveOrder(f, list, worker)
}

func pMapcomplex128PreserveOrder(f func(complex128) complex128, list []complex128, worker int) []complex128 {
	chJobs := make(chan map[int]complex128, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]complex128{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]complex128, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]complex128, chJobs chan map[int]complex128) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]complex128{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]complex128, len(list))
	newList := make([]complex128, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapcomplex128NoOrder(f func(complex128) complex128, list []complex128, worker int) []complex128 {
	chJobs := make(chan complex128, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan complex128, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan complex128, chJobs chan complex128) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]complex128, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapcomplex128Ptr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapcomplex128Ptr(f func(*complex128) *complex128, list []*complex128, optional ...fp.Optional) []*complex128 {
	if f == nil {
		return []*complex128{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapcomplex128PtrNoOrder(f, list, worker)
		}
	}

	return pMapcomplex128PtrPreserveOrder(f, list, worker)
}

func pMapcomplex128PtrPreserveOrder(f func(*complex128) *complex128, list []*complex128, worker int) []*complex128 {
	chJobs := make(chan map[int]*complex128, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*complex128{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*complex128, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*complex128, chJobs chan map[int]*complex128) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*complex128{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*complex128, len(list))
	newList := make([]*complex128, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapcomplex128PtrNoOrder(f func(*complex128) *complex128, list []*complex128, worker int) []*complex128 {
	chJobs := make(chan *complex128, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *complex128, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *complex128, chJobs chan *complex128) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*complex128, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapcomplex128PtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapcomplex128PtrErr(f func(*complex128) (*complex128, error), list []*complex128, optional ...fp.Optional) ([]*complex128, error) {
	if f == nil {
		return []*complex128{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapcomplex128PtrErrNoOrder(f, list, worker)
		}
	}

	return pMapcomplex128PtrErrPreserveOrder(f, list, worker)
}

func pMapcomplex128PtrErrPreserveOrder(f func(*complex128) (*complex128, error), list []*complex128, worker int) ([]*complex128, error) {
	chJobs := make(chan map[int]*complex128, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*complex128{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*complex128, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*complex128, chJobs chan map[int]*complex128, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*complex128{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*complex128, len(list))
	newList := make([]*complex128, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*complex128{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*complex128{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapcomplex128PtrErrNoOrder(f func(*complex128) (*complex128, error), list []*complex128, worker int) ([]*complex128, error) {
	chJobs := make(chan *complex128, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *complex128, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *complex128, chJobs chan *complex128, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*complex128, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*complex128{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*complex128{}, <-errCh
	}

	return newList, nil
}

// PMapcomplex128Err applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapcomplex128Err(f func(complex128) (complex128, error), list []complex128, optional ...fp.Optional) ([]complex128, error) {
	if f == nil {
		return []complex128{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapcomplex128ErrNoOrder(f, list, worker)
		}
	}

	return pMapcomplex128ErrPreserveOrder(f, list, worker)
}

func pMapcomplex128ErrPreserveOrder(f func(complex128) (complex128, error), list []complex128, worker int) ([]complex128, error) {
	chJobs := make(chan map[int]complex128, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]complex128{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]complex128, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]complex128, chJobs chan map[int]complex128, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]complex128{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]complex128, len(list))
	newList := make([]complex128, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []complex128{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []complex128{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapcomplex128ErrNoOrder(f func(complex128) (complex128, error), list []complex128, worker int) ([]complex128, error) {
	chJobs := make(chan complex128, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan complex128, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan complex128, chJobs chan complex128, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]complex128, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []complex128{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []complex128{}, <-errCh
	}

	return newList, nil
}

func FilterMapcomplex128(fFilter func(complex128) bool, fMap func(complex128) complex128, list []complex128) []complex128 {
	if fFilter == nil || fMap == nil {
		return []complex128{}
	}
	var newList []complex128
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapcomplex128Ptr(fFilter func(*complex128) bool, fMap func(*complex128) *complex128, list []*complex128) []*complex128 {
	if fFilter == nil || fMap == nil {
		return []*complex128{}
	}
	var newList []*complex128
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapcomplex128PtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*complex128) and returns (bool, error).
//	2. Function: takes *complex128 as argument and returns (*complex128, error)
// 	3. Slice of type []*complex128
//
// Returns:
//	New List ([]*complex128, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapcomplex128PtrErr(fFilter func(*complex128) (bool, error), fMap func(*complex128) (*complex128, error), list []*complex128) ([]*complex128, error) {
	if fFilter == nil || fMap == nil {
		return []*complex128{}, nil
	}
	var newList []*complex128
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapcomplex128Err filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(complex128) and returns (bool, error).
//	2. Function: takes complex128 as argument and returns (complex128, error)
// 	3. Slice of type []complex128
//
// Returns:
//	New List ([]complex128, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapcomplex128Err(fFilter func(complex128) (bool, error), fMap func(complex128) (complex128, error), list []complex128) ([]complex128, error) {
	if fFilter == nil || fMap == nil {
		return []complex128{}, nil
	}
	var newList []complex128
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func Restcomplex128(l []complex128) []complex128 {
	if l == nil {
		return []complex128{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []complex128{}
	}

	newList := make([]complex128, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

// Restcomplex128 removes 1st item of the list and return new list having rest of the items
func Restcomplex128Ptr(l []*complex128) []*complex128 {
	if l == nil {
		return []*complex128{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*complex128{}
	}

	newList := make([]*complex128, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func Reducecomplex128(f func(complex128, complex128) complex128, list []complex128, initializer ...complex128) complex128 {
	var init complex128
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return Reducecomplex128(f, list[1:], r)
}

func Reducecomplex128Ptr(f func(*complex128, *complex128) *complex128, list []*complex128, initializer ...complex128) *complex128 {
	var initVal complex128
	var init *complex128 = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return Reducecomplex128Ptr(f, list[1:], *r)
}

// Reducecomplex128PtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*complex128, *complex128)
//	B. list of type []*complex128
// 	C. initializer (optional of type complex128)
//
// Returns:
//	single value, error: (*complex128, error)
func Reducecomplex128PtrErr(f func(*complex128, *complex128) (*complex128, error), list []*complex128, initializer ...complex128) (*complex128, error) {
	var initVal complex128
	var init *complex128 = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return Reducecomplex128PtrErr(f, list[1:], *r)
}

// Reducecomplex128Err reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (complex128, complex128)
//	B. list of type []complex128
// 	C. initializer (optional of type complex128)
//
// Returns:
//	single value, error: (complex128, error)
func Reducecomplex128Err(f func(complex128, complex128) (complex128, error), list []complex128, initializer ...complex128) (complex128, error) {
	var initVal complex128
	var init complex128 = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return Reducecomplex128Err(f, list[1:], r)
}

// DropLastcomplex128 drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastcomplex128(list []complex128) []complex128 {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []complex128{}
	}

	newList := make([]complex128, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastcomplex128Ptr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastcomplex128Ptr(list []*complex128) []*complex128 {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*complex128{}
	}

	newList := make([]*complex128, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// Reversecomplex128s reverse the list
func Reversecomplex128s(list []complex128) []complex128 {
	newList := make([]complex128, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// Reversecomplex128sPtr reverse the list
func Reversecomplex128sPtr(list []*complex128) []*complex128 {
	newList := make([]*complex128, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// Takecomplex128 returns n items in the list
func Takecomplex128(n int, list []complex128) []complex128 {
	if n < 0 {
		return []complex128{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]complex128, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// Takecomplex128Ptr returns n items in the list
func Takecomplex128Ptr(n int, list []*complex128) []*complex128 {
	if n < 0 {
		return []*complex128{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*complex128, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// Distinctcomplex128P returns true if no two of the arguments are =
func Distinctcomplex128P(list []complex128) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[complex128]bool)
	for _, v := range list {
		if _, ok := s[v]; ok {
			return false
		}
		s[v] = true
	}
	return true
}

// Distinctcomplex128PPtr returns true if no two of the arguments are =
func Distinctcomplex128PPtr(list []*complex128) bool {
	if len(list) == 0 {
		return false
	}

	s := make(map[complex128]bool)
	for _, v := range list {
		if _, ok := s[*v]; ok {
			return false
		}
		s[*v] = true
	}
	return true
}

// Distinctcomplex128 removes duplicates.
func Distinctcomplex128(list []complex128) []complex128 {
	var newList []complex128
	s := make(map[complex128]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[v]; ok {
			continue
		}
		s[v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// Distinctcomplex128Ptr removes duplicates.
func Distinctcomplex128Ptr(list []*complex128) []*complex128 {
	var newList []*complex128
	s := make(map[complex128]struct{}, len(list))
	for _, v := range list {
		if _, ok := s[*v]; ok {
			continue
		}
		s[*v] = struct{}{}
		newList = append(newList, v)
	}
	return newList
}

// Unioncomplex128 return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func Unioncomplex128(arrList ...[]complex128) []complex128 {
	resultMap := make(map[complex128]bool)
	for _, arr := range arrList {
		for _, v := range arr {
			resultMap[v] = true
		}
	}

	resultArr := make([]complex128, len(resultMap))
	i := 0
	for k := range resultMap {
		resultArr[i] = k
		i++
	}
	return resultArr
}

// Unioncomplex128Ptr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func Unioncomplex128Ptr(arrList ...[]*complex128) []*complex128 {
	resultMap := make(map[complex128]bool)
	var resultArr []*complex128
	for _, arr := range arrList {
		for _, v := range arr {
			_, ok := resultMap[*v]
			if !ok {
				resultMap[*v] = true
				resultArr = append(resultArr, v)
			}
		}
	}
	return resultArr
}

// Intersectioncomplex128 return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func Intersectioncomplex128(arrList ...[]complex128) []complex128 {
	if arrList == nil {
		return []complex128{}
	}

	resultMap := make(map[complex128]bool)
	if len(arrList) == 1 {
		var newList []complex128
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []complex128
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// Intersectioncomplex128Ptr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func Intersectioncomplex128Ptr(arrList ...[]*complex128) []*complex128 {
	if arrList == nil {
		return []*complex128{}
	}

	resultMap := make(map[complex128]bool)
	if len(arrList) == 1 {
		var newList []*complex128
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*complex128
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// Differencecomplex128 returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func Differencecomplex128(arrList ...[]complex128) []complex128 {
	if arrList == nil {
		return []complex128{}
	}

	resultMap := make(map[complex128]bool)
	if len(arrList) == 1 {
		var newList []complex128
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
		return newList
	}

	var newList []complex128
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if arrList[0][i] == v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[arrList[0][i]] = true
			}
		}
	}
	return newList
}

// Differencecomplex128Ptr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func Differencecomplex128Ptr(arrList ...[]*complex128) []*complex128 {
	if arrList == nil {
		return []*complex128{}
	}

	resultMap := make(map[complex128]bool)
	if len(arrList) == 1 {
		var newList []*complex128
		for i := 0; i < len(arrList[0]); i++ {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				resultMap[*arrList[0][i]] = true
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	var newList []*complex128
	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if *arrList[0][i] == *v {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			_, ok := resultMap[*arrList[0][i]]
			if !ok {
				newList = append(newList, arrList[0][i])
				resultMap[*arrList[0][i]] = true
			}
		}
	}
	return newList
}

// Subsetcomplex128 returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func Subsetcomplex128(list1, list2 []complex128) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[complex128]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[list1[i]]
		if !ok {
			found := false
			resultMap[list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// Subsetcomplex128Ptr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored
func Subsetcomplex128Ptr(list1, list2 []*complex128) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[complex128]bool)
	for i := 0; i < len(list1); i++ {
		_, ok := resultMap[*list1[i]]
		if !ok {
			found := false
			resultMap[*list1[i]] = true
			for j := 0; j < len(list2); j++ {
				if list1[i] == list2[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// Supersetcomplex128 returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func Supersetcomplex128(list1, list2 []complex128) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[complex128]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[list2[i]]
		if !ok {
			found := false
			resultMap[list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// Supersetcomplex128Ptr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored
func Supersetcomplex128Ptr(list1, list2 []*complex128) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	resultMap := make(map[complex128]bool)

	for i := 0; i < len(list2); i++ {
		_, ok := resultMap[*list2[i]]
		if !ok {
			found := false
			resultMap[*list2[i]] = true
			for j := 0; j < len(list1); j++ {
				if list2[i] == list1[j] {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}
	return true
}

// Setcomplex128 returns a set of the distinct elements of coll.
func Setcomplex128(list []complex128) []complex128 {
	if list == nil || len(list) == 0 {
		return []complex128{}
	}

	resultMap := make(map[complex128]bool)
	newList := []complex128{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[list[i]]
		if !ok {
			resultMap[list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}

// Setcomplex128Ptr returns a set of the distinct elements of coll.
func Setcomplex128Ptr(list []*complex128) []*complex128 {
	if list == nil || len(list) == 0 {
		return []*complex128{}
	}

	resultMap := make(map[complex128]bool)
	newList := []*complex128{}
	for i := 0; i < len(list); i++ {
		_, ok := resultMap[*list[i]]
		if !ok {
			resultMap[*list[i]] = true
			newList = append(newList, list[i])
		}
	}
	return newList
}
