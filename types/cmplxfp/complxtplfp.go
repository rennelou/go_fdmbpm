// Code generated by 'gofp'. DO NOT EDIT.
package cmplxfp

import "reflect"
import _ "sort"
import "sync"
import "github.com/logic-building/functional-go/fp"

func MapAlphaBeta(f func(AlphaBeta) AlphaBeta, list []AlphaBeta) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}
	newList := make([]AlphaBeta, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

func MapAlphaBetaPtr(f func(*AlphaBeta) *AlphaBeta, list []*AlphaBeta) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}
	newList := make([]*AlphaBeta, len(list))
	for i, v := range list {
		newList[i] = f(v)
	}
	return newList
}

// MapAlphaBetaPtrErr takes 2 arguments:
//  1. A function input argument: *AlphaBeta and return types (*AlphaBeta, error)
//  2. A list of type []*AlphaBeta
//
// Returns:
// 	([]*AlphaBeta, error)
func MapAlphaBetaPtrErr(f func(*AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}
	newList := make([]*AlphaBeta, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

// MapAlphaBetaErr takes 2 arguments:
//  1. A function input argument: AlphaBeta and return types (AlphaBeta, error)
//  2. A list of type []AlphaBeta
//
// Returns:
// 	([]AlphaBeta, error)
func MapAlphaBetaErr(f func(AlphaBeta) (AlphaBeta, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}
	newList := make([]AlphaBeta, len(list))
	for i, v := range list {
		var err error
		newList[i], err = f(v)
		if err != nil {
			return nil, err
		}
	}
	return newList, nil
}

func FilterAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}
	var newList []AlphaBeta
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func FilterAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}
	var newList []*AlphaBeta
	for _, v := range list {
		if f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// FilterAlphaBetaPtrErr takes two arguments
//  1. Function: takes 1 argument of type AlphaBeta and returns (bool, error)
//  2. slice of type []*AlphaBeta
//
// Returns:
//  new filtered list and error
func FilterAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}
	var newList []*AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// FilterAlphaBetaErr takes two arguments
//  1. Function: takes 1 argument of type AlphaBeta and returns (bool, error)
//  2. slice of type []AlphaBeta
//
// Returns:
//  new filtered list and error
func FilterAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}
	var newList []AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func RemoveAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}
	var newList []AlphaBeta
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

func RemoveAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}
	var newList []*AlphaBeta
	for _, v := range list {
		if !f(v) {
			newList = append(newList, v)
		}
	}
	return newList
}

// RemoveAlphaBetaPtrErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type *AlphaBeta and return types(bool, error)
//	2. List of type: []*AlphaBeta
//
// Returns:
//	New list and error: ([]*AlphaBeta, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}
	var newList []*AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

// RemoveAlphaBetaErr removes the items from the given list based on supplied function and returns new list
//
// Takes 2 inputs:
//	1. Function: input type AlphaBeta and return types(bool, error)
//	2. List of type: []AlphaBeta
//
// Returns:
//	New list and error: ([]AlphaBeta, error)
//	Empty list if both of arguments are nil or either one is nil.
func RemoveAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}
	var newList []AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			newList = append(newList, v)
		}
	}
	return newList, nil
}

func SomeAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

func SomeAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) bool {
	if f == nil {
		return false
	}
	for _, v := range list {
		if f(v) {
			return true
		}
	}
	return false
}

// SomeAlphaBetaPtrErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

// SomeAlphaBetaErr finds item in the list based on supplied function.
//
// Takes 2 input:
//	1. Function
//	2. List
//
// Returns:
//	(bool,err).
//	True if condition satisfies, else false
func SomeAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) (bool, error) {
	if f == nil {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if r {
			return true, nil
		}
	}
	return false, nil
}

func EveryAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

func EveryAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) bool {
	if f == nil || len(list) == 0 {
		return false
	}
	for _, v := range list {
		if !f(v) {
			return false
		}
	}
	return true
}

// EveryAlphaBetaPtrErr returns true if supplied function returns logical true for every item in the list
func EveryAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

// EveryAlphaBetaErr returns true if supplied function returns logical true for every item in the list
func EveryAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) (bool, error) {
	if f == nil || len(list) == 0 {
		return false, nil
	}
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return false, err
		}
		if !r {
			return false, nil
		}
	}
	return true, nil
}

func DropWhileAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}
	var newList []AlphaBeta
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]AlphaBeta, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

func DropWhileAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}
	var newList []*AlphaBeta
	for i, v := range list {
		if !f(v) {
			listLen := len(list)
			newList = make([]*AlphaBeta, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList
		}
	}
	return newList
}

// DropWhileAlphaBetaPtrErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}
	var newList []*AlphaBeta
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]*AlphaBeta, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

// DropWhileAlphaBetaErr drops the items from the list as long as condition satisfies.
//
// Takes two inputs
//	1. Function: takes one input and returns (boolean, error)
//	2. list
//
// Returns:
// 	New List, error
//  Empty list if either one of arguments or both of them are nil
func DropWhileAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}
	var newList []AlphaBeta
	for i, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			listLen := len(list)
			newList = make([]AlphaBeta, listLen-i)
			j := 0
			for i < listLen {
				newList[j] = list[i]
				i++
				j++
			}
			return newList, nil
		}
	}
	return newList, nil
}

func TakeWhileAlphaBeta(f func(AlphaBeta) bool, list []AlphaBeta) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}
	var newList []AlphaBeta
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

func TakeWhileAlphaBetaPtr(f func(*AlphaBeta) bool, list []*AlphaBeta) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}
	var newList []*AlphaBeta
	for _, v := range list {
		if !f(v) {
			return newList
		}
		newList = append(newList, v)
	}
	return newList
}

// TakeWhileAlphaBetaPtrErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type *AlphaBeta and returns ([]*AlphaBeta, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileAlphaBetaPtrErr(f func(*AlphaBeta) (bool, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}
	var newList []*AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// TakeWhileAlphaBetaErr returns new list based on condition in the supplied function. It returns new list once condition fails.
//
// Takes 2 inputs:
//	1. Function - 1 input of type AlphaBeta and returns ([]AlphaBeta, error)
//	2. List
//
// Returns:
//	New List, error.
//	Empty list if all the parameters are nil or either of one parameter is nil
func TakeWhileAlphaBetaErr(f func(AlphaBeta) (bool, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}
	var newList []AlphaBeta
	for _, v := range list {
		r, err := f(v)
		if err != nil {
			return nil, err
		}
		if !r {
			return newList, nil
		}
		newList = append(newList, v)
	}
	return newList, nil
}

// PMapAlphaBeta applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapAlphaBeta(f func(AlphaBeta) AlphaBeta, list []AlphaBeta, optional ...fp.Optional) []AlphaBeta {
	if f == nil {
		return []AlphaBeta{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapAlphaBetaNoOrder(f, list, worker)
		}
	}

	return pMapAlphaBetaPreserveOrder(f, list, worker)
}

func pMapAlphaBetaPreserveOrder(f func(AlphaBeta) AlphaBeta, list []AlphaBeta, worker int) []AlphaBeta {
	chJobs := make(chan map[int]AlphaBeta, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]AlphaBeta{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]AlphaBeta, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]AlphaBeta, chJobs chan map[int]AlphaBeta) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]AlphaBeta{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]AlphaBeta, len(list))
	newList := make([]AlphaBeta, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapAlphaBetaNoOrder(f func(AlphaBeta) AlphaBeta, list []AlphaBeta, worker int) []AlphaBeta {
	chJobs := make(chan AlphaBeta, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan AlphaBeta, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan AlphaBeta, chJobs chan AlphaBeta) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]AlphaBeta, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapAlphaBetaPtr applies the function(1st argument) on each item in the list and returns a new list.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapAlphaBetaPtr(f func(*AlphaBeta) *AlphaBeta, list []*AlphaBeta, optional ...fp.Optional) []*AlphaBeta {
	if f == nil {
		return []*AlphaBeta{}
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapAlphaBetaPtrNoOrder(f, list, worker)
		}
	}

	return pMapAlphaBetaPtrPreserveOrder(f, list, worker)
}

func pMapAlphaBetaPtrPreserveOrder(f func(*AlphaBeta) *AlphaBeta, list []*AlphaBeta, worker int) []*AlphaBeta {
	chJobs := make(chan map[int]*AlphaBeta, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*AlphaBeta{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*AlphaBeta, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*AlphaBeta, chJobs chan map[int]*AlphaBeta) {
			defer wg.Done()

			for m := range chJobs {
				for k, v := range m {
					chResult <- map[int]*AlphaBeta{k: f(v)}
				}
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*AlphaBeta, len(list))
	newList := make([]*AlphaBeta, len(list))

	for m := range chResult {
		for k, v := range m {
			newListMap[k] = v
		}
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList
}

func pMapAlphaBetaPtrNoOrder(f func(*AlphaBeta) *AlphaBeta, list []*AlphaBeta, worker int) []*AlphaBeta {
	chJobs := make(chan *AlphaBeta, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *AlphaBeta, worker/3)

	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *AlphaBeta, chJobs chan *AlphaBeta) {
			defer wg.Done()

			for v := range chJobs {
				chResult <- f(v)
			}
		}(chResult, chJobs)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*AlphaBeta, len(list))
	i := 0

	for v := range chResult {
		newList[i] = v
		i++
	}

	return newList
}

// PMapAlphaBetaPtrErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapAlphaBetaPtrErr(f func(*AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta, optional ...fp.Optional) ([]*AlphaBeta, error) {
	if f == nil {
		return []*AlphaBeta{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapAlphaBetaPtrErrNoOrder(f, list, worker)
		}
	}

	return pMapAlphaBetaPtrErrPreserveOrder(f, list, worker)
}

func pMapAlphaBetaPtrErrPreserveOrder(f func(*AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta, worker int) ([]*AlphaBeta, error) {
	chJobs := make(chan map[int]*AlphaBeta, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]*AlphaBeta{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]*AlphaBeta, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]*AlphaBeta, chJobs chan map[int]*AlphaBeta, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]*AlphaBeta{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]*AlphaBeta, len(list))
	newList := make([]*AlphaBeta, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []*AlphaBeta{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []*AlphaBeta{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapAlphaBetaPtrErrNoOrder(f func(*AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta, worker int) ([]*AlphaBeta, error) {
	chJobs := make(chan *AlphaBeta, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan *AlphaBeta, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan *AlphaBeta, chJobs chan *AlphaBeta, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]*AlphaBeta, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []*AlphaBeta{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []*AlphaBeta{}, <-errCh
	}

	return newList, nil
}

// PMapAlphaBetaErr applies the function(1st argument) on each item in the list and returns a new list and error.
//  Order of new list is guaranteed. This feature can be disabled by passing: Optional{RandomOrder: true} to gain performance
//  Run in parallel. no_of_goroutines = no_of_items_in_list or 3rd argument can be passed to fix the number of goroutines.
//
// Takes 3 inputs. 3rd argument is optional
//  1. Function - takes 1 input
//  2. List
//  3. optional argument - fp.Optional{FixedPool: <some_number>}
func PMapAlphaBetaErr(f func(AlphaBeta) (AlphaBeta, error), list []AlphaBeta, optional ...fp.Optional) ([]AlphaBeta, error) {
	if f == nil {
		return []AlphaBeta{}, nil
	}

	var worker = len(list)
	if optional != nil && len(optional) > 0 {
		if optional[0].FixedPool > 0 && optional[0].FixedPool < worker {
			worker = optional[0].FixedPool
		}

		if optional[0].RandomOrder == true {
			return pMapAlphaBetaErrNoOrder(f, list, worker)
		}
	}

	return pMapAlphaBetaErrPreserveOrder(f, list, worker)
}

func pMapAlphaBetaErrPreserveOrder(f func(AlphaBeta) (AlphaBeta, error), list []AlphaBeta, worker int) ([]AlphaBeta, error) {
	chJobs := make(chan map[int]AlphaBeta, len(list))
	go func() {
		for i, v := range list {
			chJobs <- map[int]AlphaBeta{i: v}
		}
		close(chJobs)
	}()

	chResult := make(chan map[int]AlphaBeta, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan map[int]AlphaBeta, chJobs chan map[int]AlphaBeta, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for m := range chJobs {
				for k, v := range m {
					r, err := f(v)
					if err != nil {
						errCh <- err
						return
					}
					chResult <- map[int]AlphaBeta{k: r}
				}
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newListMap := make(map[int]AlphaBeta, len(list))
	newList := make([]AlphaBeta, len(list))

	for m := range chResult {
		select {
		case err := <-errCh:
			return []AlphaBeta{}, err
		default:
		}
		for k, v := range m {
			newListMap[k] = v
		}
	}

	if len(errCh) > 0 {
		return []AlphaBeta{}, <-errCh
	}

	for i := 0; i < len(list); i++ {
		newList[i] = newListMap[i]
	}

	return newList, nil
}

func pMapAlphaBetaErrNoOrder(f func(AlphaBeta) (AlphaBeta, error), list []AlphaBeta, worker int) ([]AlphaBeta, error) {
	chJobs := make(chan AlphaBeta, len(list))
	go func() {
		for _, v := range list {
			chJobs <- v
		}
		close(chJobs)
	}()

	chResult := make(chan AlphaBeta, worker/3)

	errCh := make(chan error, len(list))
	var wg sync.WaitGroup

	for i := 0; i < worker; i++ {
		wg.Add(1)

		go func(chResult chan AlphaBeta, chJobs chan AlphaBeta, errCh chan error) {
			defer wg.Done()
			if len(errCh) > 0 {
				return
			}
			for v := range chJobs {
				r, err := f(v)
				if err != nil {
					errCh <- err
					return
				}
				chResult <- r
			}
		}(chResult, chJobs, errCh)
	}

	// This will wait for the workers to complete their job and then close the channel
	go func() {
		wg.Wait()
		close(chResult)
	}()

	newList := make([]AlphaBeta, len(list))
	i := 0

	for v := range chResult {
		select {
		case err := <-errCh:
			return []AlphaBeta{}, err
		default:
		}
		newList[i] = v
		i++
	}

	if len(errCh) > 0 {
		return []AlphaBeta{}, <-errCh
	}

	return newList, nil
}

func FilterMapAlphaBeta(fFilter func(AlphaBeta) bool, fMap func(AlphaBeta) AlphaBeta, list []AlphaBeta) []AlphaBeta {
	if fFilter == nil || fMap == nil {
		return []AlphaBeta{}
	}
	var newList []AlphaBeta
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

func FilterMapAlphaBetaPtr(fFilter func(*AlphaBeta) bool, fMap func(*AlphaBeta) *AlphaBeta, list []*AlphaBeta) []*AlphaBeta {
	if fFilter == nil || fMap == nil {
		return []*AlphaBeta{}
	}
	var newList []*AlphaBeta
	for _, v := range list {
		if fFilter(v) {
			newList = append(newList, fMap(v))
		}
	}
	return newList
}

// FilterMapAlphaBetaPtrErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(*AlphaBeta) and returns (bool, error).
//	2. Function: takes *AlphaBeta as argument and returns (*AlphaBeta, error)
// 	3. Slice of type []*AlphaBeta
//
// Returns:
//	New List ([]*AlphaBeta, error).
//  Empty list if all there parameters are nil or either of parameter is nil
func FilterMapAlphaBetaPtrErr(fFilter func(*AlphaBeta) (bool, error), fMap func(*AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta) ([]*AlphaBeta, error) {
	if fFilter == nil || fMap == nil {
		return []*AlphaBeta{}, nil
	}
	var newList []*AlphaBeta
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

// FilterMapAlphaBetaErr filters given list, then apply function(2nd argument) on each item in the list and returns a new list
// Takes 3 inputs
//	1. Function: takes one input(AlphaBeta) and returns (bool, error).
//	2. Function: takes AlphaBeta as argument and returns (AlphaBeta, error)
// 	3. Slice of type []AlphaBeta
//
// Returns:
//	New List ([]AlphaBeta, error).
//  Empty list if all there parameters are nil or either of parameter is nil
//
func FilterMapAlphaBetaErr(fFilter func(AlphaBeta) (bool, error), fMap func(AlphaBeta) (AlphaBeta, error), list []AlphaBeta) ([]AlphaBeta, error) {
	if fFilter == nil || fMap == nil {
		return []AlphaBeta{}, nil
	}
	var newList []AlphaBeta
	for _, v := range list {
		r, err := fFilter(v)
		if err != nil {
			return nil, err
		}
		if r {
			r, err := fMap(v)
			if err != nil {
				return nil, err
			}
			newList = append(newList, r)
		}
	}
	return newList, nil
}

func RestAlphaBeta(l []AlphaBeta) []AlphaBeta {
	if l == nil {
		return []AlphaBeta{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []AlphaBeta{}
	}

	newList := make([]AlphaBeta, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

// RestAlphaBeta removes 1st item of the list and return new list having rest of the items
func RestAlphaBetaPtr(l []*AlphaBeta) []*AlphaBeta {
	if l == nil {
		return []*AlphaBeta{}
	}

	len := len(l)
	if len == 0 || len == 1 {
		return []*AlphaBeta{}
	}

	newList := make([]*AlphaBeta, len-1)

	for i, v := range l[1:] {
		newList[i] = v
	}

	return newList
}

func ReduceAlphaBeta(f func(AlphaBeta, AlphaBeta) AlphaBeta, list []AlphaBeta, initializer ...AlphaBeta) AlphaBeta {
	var init AlphaBeta
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}
	r := f(init, list[0])
	return ReduceAlphaBeta(f, list[1:], r)
}

func ReduceAlphaBetaPtr(f func(*AlphaBeta, *AlphaBeta) *AlphaBeta, list []*AlphaBeta, initializer ...AlphaBeta) *AlphaBeta {
	var initVal AlphaBeta
	var init *AlphaBeta = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0]
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init
	}

	r := f(init, list[0])
	return ReduceAlphaBetaPtr(f, list[1:], *r)
}

// ReduceAlphaBetaPtrErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (*AlphaBeta, *AlphaBeta)
//	B. list of type []*AlphaBeta
// 	C. initializer (optional of type AlphaBeta)
//
// Returns:
//	single value, error: (*AlphaBeta, error)
func ReduceAlphaBetaPtrErr(f func(*AlphaBeta, *AlphaBeta) (*AlphaBeta, error), list []*AlphaBeta, initializer ...AlphaBeta) (*AlphaBeta, error) {
	var initVal AlphaBeta
	var init *AlphaBeta = &initVal
	lenList := len(list)

	if initializer != nil {
		init = &initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return nil, err
	}
	return ReduceAlphaBetaPtrErr(f, list[1:], *r)
}

// ReduceAlphaBetaErr reduces a list to a single value by combining elements via a supplied function
//
// Takes three inputs
//	A. function - takes two arguments (AlphaBeta, AlphaBeta)
//	B. list of type []AlphaBeta
// 	C. initializer (optional of type AlphaBeta)
//
// Returns:
//	single value, error: (AlphaBeta, error)
func ReduceAlphaBetaErr(f func(AlphaBeta, AlphaBeta) (AlphaBeta, error), list []AlphaBeta, initializer ...AlphaBeta) (AlphaBeta, error) {
	var initVal AlphaBeta
	var init AlphaBeta = initVal
	lenList := len(list)

	if initializer != nil {
		init = initializer[0]
	} else if lenList > 0 {
		init = list[0]
		if lenList == 1 {
			return list[0], nil
		}
		if lenList >= 2 {
			list = list[1:]
		}
	}

	if lenList == 0 {
		return init, nil
	}

	r, err := f(init, list[0])
	if err != nil {
		return r, err
	}
	return ReduceAlphaBetaErr(f, list[1:], r)
}

// DropLastAlphaBeta drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastAlphaBeta(list []AlphaBeta) []AlphaBeta {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []AlphaBeta{}
	}

	newList := make([]AlphaBeta, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DropLastAlphaBetaPtr drops last item from the list and returns new list.
// Returns empty list if there is only one item in the list or list empty
func DropLastAlphaBetaPtr(list []*AlphaBeta) []*AlphaBeta {
	listLen := len(list)

	if list == nil || listLen == 0 || listLen == 1 {
		return []*AlphaBeta{}
	}

	newList := make([]*AlphaBeta, listLen-1)

	for i := 0; i < listLen-1; i++ {
		newList[i] = list[i]
	}
	return newList
}

// ReverseAlphaBetas reverse the list
func ReverseAlphaBetas(list []AlphaBeta) []AlphaBeta {
	newList := make([]AlphaBeta, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// ReverseAlphaBetasPtr reverse the list
func ReverseAlphaBetasPtr(list []*AlphaBeta) []*AlphaBeta {
	newList := make([]*AlphaBeta, len(list))
	for i := 0; i < len(list); i++ {
		newList[i] = list[len(list)-(i+1)]
	}
	return newList
}

// TakeAlphaBeta returns n items in the list
func TakeAlphaBeta(n int, list []AlphaBeta) []AlphaBeta {
	if n < 0 {
		return []AlphaBeta{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]AlphaBeta, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// TakeAlphaBetaPtr returns n items in the list
func TakeAlphaBetaPtr(n int, list []*AlphaBeta) []*AlphaBeta {
	if n < 0 {
		return []*AlphaBeta{}
	}

	newListLen := len(list)

	if n < newListLen {
		newListLen = n
	}
	newList := make([]*AlphaBeta, newListLen)
	for i := 0; i < newListLen; i++ {
		newList[i] = list[i]
	}
	return newList
}

// DistinctAlphaBetaP returns true if no two of the arguments are =
func DistinctAlphaBetaP(list []AlphaBeta) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(list[i], list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctAlphaBetaPPtr returns true if no two of the arguments are =
func DistinctAlphaBetaPPtr(list []*AlphaBeta) bool {
	if len(list) == 0 {
		return false
	}

	for i := 0; i < len(list); i++ {
		for j := i + 1; j < len(list); j++ {
			if reflect.DeepEqual(*list[i], *list[j]) {
				return false
			}
		}
	}
	return true
}

// DistinctAlphaBeta removes duplicates.
func DistinctAlphaBeta(list []AlphaBeta) []AlphaBeta {
	if len(list) == 0 {
		return []AlphaBeta{}
	}

	newList := []AlphaBeta{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

func DistinctAlphaBetaPtr(list []*AlphaBeta) []*AlphaBeta {
	if len(list) == 0 {
		return []*AlphaBeta{}
	}

	newList := []*AlphaBeta{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// UnionAlphaBeta return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionAlphaBeta(arrList ...[]AlphaBeta) []AlphaBeta {
	var newList []AlphaBeta

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(newList[i], v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// UnionAlphaBetaPtr return a set that is the union of the input sets
// repeated value within list parameter will be ignored
func UnionAlphaBetaPtr(arrList ...[]*AlphaBeta) []*AlphaBeta {
	var newList []*AlphaBeta

	for _, arr := range arrList {
		for _, v := range arr {
			found := false
			for i := 0; i < len(newList); i++ {
				if reflect.DeepEqual(*newList[i], *v) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, v)
			}
		}
	}
	return newList
}

// IntersectionAlphaBeta return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionAlphaBeta(arrList ...[]AlphaBeta) []AlphaBeta {
	if arrList == nil {
		return []AlphaBeta{}
	}

	var newList []AlphaBeta

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// IntersectionAlphaBetaPtr return a set that is the intersection of the input sets
// repeated value within list parameter will be ignored
func IntersectionAlphaBetaPtr(arrList ...[]*AlphaBeta) []*AlphaBeta {
	if arrList == nil {
		return []*AlphaBeta{}
	}

	var newList []*AlphaBeta

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == len(arrList)-1 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceAlphaBeta returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceAlphaBeta(arrList ...[]AlphaBeta) []AlphaBeta {
	if arrList == nil {
		return []AlphaBeta{}
	}

	var newList []AlphaBeta

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(arrList[0][i], v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(newList[j], arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// DifferenceAlphaBetaPtr returns a set that is the first set without elements of the remaining sets
// repeated value within list parameter will be ignored
func DifferenceAlphaBetaPtr(arrList ...[]*AlphaBeta) []*AlphaBeta {
	if arrList == nil {
		return []*AlphaBeta{}
	}

	var newList []*AlphaBeta

	if len(arrList) == 1 {
		for i := 0; i < len(arrList[0]); i++ {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
		return newList
	}

	// 1st loop iterates items in 1st array
	// 2nd loop iterates all the rest of the arrays
	// 3rd loop iterates items in the rest of the arrays
	for i := 0; i < len(arrList[0]); i++ {

		matchCount := 0
		for j := 1; j < len(arrList); j++ {
			for _, v := range arrList[j] {
				// compare every items in 1st array to every items in the rest of the arrays
				if reflect.DeepEqual(*arrList[0][i], *v) {
					matchCount++
					break
				}
			}
		}
		if matchCount == 0 {
			found := false
			for j := 0; j < len(newList); j++ {
				if reflect.DeepEqual(*newList[j], *arrList[0][i]) {
					found = true
					break
				}
			}
			if !found {
				newList = append(newList, arrList[0][i])
			}
		}
	}
	return newList
}

// SubsetAlphaBeta returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetAlphaBeta(list1, list2 []AlphaBeta) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(list1[i], list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SubsetAlphaBetaPtr returns true or false by checking if set1 is a subset of set2
// repeated value within list parameter will be ignored, order does not matter
func SubsetAlphaBetaPtr(list1, list2 []*AlphaBeta) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list1); i++ {
		found := false
		for j := 0; j < len(list2); j++ {
			if reflect.DeepEqual(*list1[i], *list2[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetAlphaBeta returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetAlphaBeta(list1, list2 []AlphaBeta) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(list2[i], list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SupersetAlphaBetaPtr returns true or false by checking if set1 is a superset of set2
// repeated value within list parameter will be ignored, order does not matter
func SupersetAlphaBetaPtr(list1, list2 []*AlphaBeta) bool {
	if list1 == nil || len(list1) == 0 || list2 == nil || len(list2) == 0 {
		return false
	}

	for i := 0; i < len(list2); i++ {
		found := false
		for j := 0; j < len(list1); j++ {
			if reflect.DeepEqual(*list2[i], *list1[j]) {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

// SetAlphaBeta returns a set of the distinct elements of coll.
func SetAlphaBeta(list []AlphaBeta) []AlphaBeta {
	if len(list) == 0 {
		return []AlphaBeta{}
	}

	newList := []AlphaBeta{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(list[i], newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}

// SetAlphaBetaPtr returns a set of the distinct elements of coll.
func SetAlphaBetaPtr(list []*AlphaBeta) []*AlphaBeta {
	if len(list) == 0 {
		return []*AlphaBeta{}
	}

	newList := []*AlphaBeta{list[0]}

	for i := 1; i < len(list); i++ {
		found := false
		for j := 0; j < len(newList); j++ {
			if reflect.DeepEqual(*list[i], *newList[j]) {
				found = true
				break
			}
		}
		if !found {
			newList = append(newList, list[i])
		}
	}
	return newList
}
